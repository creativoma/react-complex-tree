"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7937],{9377:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>h});var r=n(7896),a=(n(2784),n(876));const o={},i="Frequently Asked Questions",l={unversionedId:"faq",id:"faq",title:"Frequently Asked Questions",description:"\x3c!--",source:"@site/docs/faq.mdx",sourceDirName:".",slug:"/faq",permalink:"/docs/faq",draft:!1,editUrl:"https://github.com/lukasbach/react-complex-tree/edit/main/packages/docs/docs/faq.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Changelog",permalink:"/docs/changelog"}},s={},h=[],c={toc:h};function u(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"frequently-asked-questions"},"Frequently Asked Questions"),(0,a.kt)("p",null,"The following are a list of questions and answers that I collected from the issue tracker of react-complex-tree."),(0,a.kt)("p",null,"Feel free to contribute additional questions and answers if you think they are relevant."),(0,a.kt)("details",null,(0,a.kt)("summary",null,"I implemented a tree using StaticTreeDataProvider, how can I change the tree state, like adding or updating items?"),(0,a.kt)("div",null,(0,a.kt)("p",null,"If you want to react to tree state changes, I suggest you implement a custom\n",(0,a.kt)("a",{parentName:"p",href:"https://rct.lukasbach.com/docs/api/interfaces/TreeDataProvider"},"TreeDataProvider"),"\nrather than using\nStaticTreeDataProvider. There you can implement logic that reacts to change events. If you need more\ncontrol, you can also use a ",(0,a.kt)("a",{parentName:"p",href:"https://rct.lukasbach.com/docs/guides/controlled-environment"},"controlled environment"),"\nrather than an uncontrolled environment, then you get complete control over your data."),(0,a.kt)("p",null,"Reference: ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/lukasbach/react-complex-tree/issues/244"},"#244")))),(0,a.kt)("details",null,(0,a.kt)("summary",null,"When I implement renderRenameInput, rename hooks are not called when clicking the rename submit button"),(0,a.kt)("div",null,(0,a.kt)("p",null,"Make sure to add ",(0,a.kt)("inlineCode",{parentName:"p"},"ref={props.submitButtonRef}")," to the props of the submit button, then it should work. RCT checks if\nthe input is blurred, i.e. the user clicks away from the input, and when that is the case, it cancels the renaming\nand hides the rename input. It uses a ref on the button to find out that the user is not actually cancelling the\nrenaming, but clicking on the submit button. So without the ref, it thinks the user is just clicking away from the\ninput, and unmounts the button and input before the submit logic can complete."),(0,a.kt)("p",null,"Reference: ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/lukasbach/react-complex-tree/issues/247"},"#247")))),(0,a.kt)("details",null,(0,a.kt)("summary",null,"How can I implement custom drop handlers? What is the difference between linearIndex and childIndex?"),(0,a.kt)("div",null,(0,a.kt)("p",null,"The gist is essentially just to implement the\n",(0,a.kt)("a",{parentName:"p",href:"https://rct.lukasbach.com/docs/api/interfaces/TreeChangeHandlers#ondrop"},"onDrop"),"\nhandler, you can use\n",(0,a.kt)("a",{parentName:"p",href:"https://github.com/lukasbach/react-complex-tree/blob/main/packages/core/src/uncontrolledEnvironment/UncontrolledTreeEnvironment.tsx#L116"},"the implementation in the uncontrolled environment"),"\nfor that as reference, although it is a bit verbose and messy to be honest."),(0,a.kt)("p",null,'When the user is dropping an item, he is hovering over an ("target") item. The target type provides details where on that item that is:'),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},'"item": User is dropping in the center part of an item. This means the item is a folder and ',(0,a.kt)("inlineCode",{parentName:"li"},"props.canDropOnFolder")," is true, or it is not a folder and ",(0,a.kt)("inlineCode",{parentName:"li"},"props.canDropOnNonFolder ")," is true. The expectation is that the dragged items are inserted into the hovered target item. The target variable provided to the onDrop handler is of type ",(0,a.kt)("a",{parentName:"li",href:"https://rct.lukasbach.com/docs/api/interfaces/DraggingPositionItem"},(0,a.kt)("inlineCode",{parentName:"a"},"DraggingPositionItem"))),(0,a.kt)("li",{parentName:"ul"},'"between-items": User is either dragging on the top part or bottom part of the hovered item. The expactation is that the dragged items are inserted above the target item if they are hovering on the top part, or below if they are hovering on the bottom part. The target variable provided to the onDrop handler is of type ',(0,a.kt)("a",{parentName:"li",href:"https://rct.lukasbach.com/docs/api/interfaces/DraggingPositionBetweenItems"},(0,a.kt)("inlineCode",{parentName:"a"},"DraggingPositionBetweenItems")),". The variable ",(0,a.kt)("inlineCode",{parentName:"li"},"target.linePosition"),' has the value "top" or "bottom" and determines this distinction.'),(0,a.kt)("li",{parentName:"ul"},'"root": The user is dragging somewhere on the the top-level of the tree. This means, either the tree is empty, and the user is dropping on the empty tree container, or the container in which the tree items are rendered extends downwards of the last item, and the user is dropping there. The expecation is that the item is inserted in the top-level of the tree at the bottom. This is demonstrated in ',(0,a.kt)("a",{parentName:"li",href:"https://rct.lukasbach.com/storybook/?path=/story/core-basic-examples--drop-on-empty-tree"},"this demo"),", and was introduced as fix for #182 (",(0,a.kt)("a",{parentName:"li",href:"https://github.com/lukasbach/react-complex-tree/commit/fbd7aeec6eef7c5f4e21bc626f2052dfe3ebfd7a"},"commit"),'). In implementation, I think you can handle this identical to the targetType "item", since in the case of "root", the other props are identical to the "item" case with the referencing item being the root item. The target variable provided to the onDrop handler is of type ',(0,a.kt)("a",{parentName:"li",href:"https://rct.lukasbach.com/docs/api/interfaces/DraggingPositionRoot"},(0,a.kt)("inlineCode",{parentName:"a"},"DraggingPositionRoot")))),(0,a.kt)("p",null,"Regarding ",(0,a.kt)("inlineCode",{parentName:"p"},"linearIndex")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"childIndex"),": childIndex refers to the position of an item within its parent. linearIndex refers to the overall position of the item within the entire tree, would all items be laid out in a linear manner. As an example:"),(0,a.kt)("p",null,(0,a.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/4140121/213594609-2b9626e3-d185-4052-b4a6-1c61b96579c5.png",alt:"image"})),(0,a.kt)("p",null,'The item "Black" has the childIndex 2, and the linearIndex 5.'),(0,a.kt)("p",null,"Reference: ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/lukasbach/react-complex-tree/issues/211"},"#211")))),(0,a.kt)("details",null,(0,a.kt)("summary",null,"When dropping items on files (i.e. non-folders) with canDropOnNonFolder enabled, the dropped items vanish."),(0,a.kt)("div",null,(0,a.kt)("p",null,"This is by design. Dropping an item on a non-folder adds it to its children, but does not enable the ",(0,a.kt)("inlineCode",{parentName:"p"},"isFolder")," flag\nfor the drop target. Items are only rendered with children if they have the ",(0,a.kt)("inlineCode",{parentName:"p"},"isFolder")," flag set to true."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"If you want users to drop only on folders, enable ",(0,a.kt)("inlineCode",{parentName:"li"},"canDropOnFolder")," instead of ",(0,a.kt)("inlineCode",{parentName:"li"},"canDropOnNonFolder"),", and also\n",(0,a.kt)("inlineCode",{parentName:"li"},"canReorderItems")," if you want to allow reordering"),(0,a.kt)("li",{parentName:"ul"},"If you want to have items turn into folders with children when you drop an item on it, use a class as data provider\nthat implements ",(0,a.kt)("inlineCode",{parentName:"li"},"TreeDataProvider.onChangeItemChildren")," to handle the new items by turning the item into a folder\nand notifying rct of changes with the listeners passed by ",(0,a.kt)("inlineCode",{parentName:"li"},"TreeDataProvider.onDidChangeTreeData"),". Or implement that\naccordingly with ",(0,a.kt)("inlineCode",{parentName:"li"},"StaticTreeDataProvider")," or an controlled environment by handling that yourself."),(0,a.kt)("li",{parentName:"ul"},"Similarly, if you want other special handling of items that are dropped on other non-folder items, but not turn the\ntarget into a folder, handle the drop event just as above, but for this case it is very much necessary for rct not\nto impose implicit changes like the drop target automatically turning into a folder.")),(0,a.kt)("p",null,"Reference: ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/lukasbach/react-complex-tree/issues/228"},"#228")))),(0,a.kt)("details",null,(0,a.kt)("summary",null,"How do I alternate background color of rows?"),(0,a.kt)("div",null,(0,a.kt)("p",null,"Currently, there is no direct support from the library for that. There are some workarounds that might be feasible\nfor you:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use ",(0,a.kt)("inlineCode",{parentName:"li"},"background-image: repeat-linear-gradient")," on the parent for a repeating pattern that matches the items height."),(0,a.kt)("li",{parentName:"ul"},"Customize the styling with the DOM API:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'[...document.getElementsByClassName("rct-tree-item-button")]\n.filter((_, i) => i % 2 === 0)\n.forEach(n => n.style.backgroundColor = "red")\n')),(0,a.kt)("p",null,"Reference: ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/lukasbach/react-complex-tree/issues/217"},"#217")))),(0,a.kt)("details",null,(0,a.kt)("summary",null,"Can I turn off multi-select?"),(0,a.kt)("div",null,(0,a.kt)("p",null,"There is no direct property that controls this."),(0,a.kt)("p",null,"You should be able to achieve that by implementing a custom interaction mode. You can read about\nthose ",(0,a.kt)("a",{parentName:"p",href:"https://rct.lukasbach.com/docs/guides/interaction-modes#custom-interaction-modes"},"here"),", and see\nan example implementation ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/lukasbach/react-complex-tree/blob/main/packages/core/src/interactionMode/ClickItemToExpandInteractionManager.ts"},"here"),".\nYou can probably just copy the code from the latter link, and remove all logic that is related to multi item selection."),(0,a.kt)("p",null,"Another alternative would be to use a ",(0,a.kt)("a",{parentName:"p",href:"https://rct.lukasbach.com/docs/guides/controlled-environment"},"controlled environment"),",\nwhere you manage changes to the view state, including selected items, yourself. There you could also customize\nhow item selection is handled."),(0,a.kt)("p",null,"Reference: ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/lukasbach/react-complex-tree/issues/151"},"#151")))),(0,a.kt)("details",null,(0,a.kt)("summary",null,"How can I hide an folder arrow when all children are moved?"),(0,a.kt)("div",null,(0,a.kt)("p",null,"Whether arrow is  shown or not depends only on ",(0,a.kt)("inlineCode",{parentName:"p"},"isFolder")," (previously ",(0,a.kt)("inlineCode",{parentName:"p"},"hasChildren"),") prop of the node. So you have to\nchange that property for the node when all children are moved out."),(0,a.kt)("p",null,"Reference: ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/lukasbach/react-complex-tree/issues/188"},"#188")," and ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/lukasbach/react-complex-tree/pull/70"},"#70")))),(0,a.kt)("details",null,(0,a.kt)("summary",null,"I want the user to be able to drop items on the bottom of the tree or into an empty tree."),(0,a.kt)("div",null,(0,a.kt)("p",null,"This already works by default.\nPlease note that the drag-over needs to be performed over the tree container component for it to register\non empty trees, so the tree container component needs a minimum height for it to work. You can customize\nthis by giving a minimum height to the component rendered with renderTreeContainer which receives the containerProps."),(0,a.kt)("p",null,"Reference: ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/lukasbach/react-complex-tree/issues/182"},"#182")))),(0,a.kt)("details",null,(0,a.kt)("summary",null,"I want to control the search input state or render the input somewhere else."),(0,a.kt)("div",null,(0,a.kt)("p",null,"If you just want to control the search state from outside, you can already do that via the ref from the tree. Note\nthat the search state lives within a tree, not a tree environment, so you need to grab the ref from the tree\ncomponent, not the environment. You can set the current search value with\n",(0,a.kt)("a",{parentName:"p",href:"https://rct.lukasbach.com/docs/api/interfaces/TreeRef#setsearch"},"treeRef.setSearch()"),", or close the search by\ninvoking it with ",(0,a.kt)("inlineCode",{parentName:"p"},"null"),"."),(0,a.kt)("p",null,"If you would also like to not show the included search bar, you can update the\n",(0,a.kt)("a",{parentName:"p",href:"https://rct.lukasbach.com/docs/api/interfaces/TreeRenderProps#rendersearchinput"},(0,a.kt)("inlineCode",{parentName:"a"},"renderSearchInput"))," prop\nto ",(0,a.kt)("inlineCode",{parentName:"p"},"() => null"),"."),(0,a.kt)("p",null,"Alternatively you could also adjust ",(0,a.kt)("inlineCode",{parentName:"p"},"renderSearchInput")," to render a portal that mounts the search input in a\ndifferent location within your place, and customize how the search bar looks like from there."),(0,a.kt)("p",null,"Reference: ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/lukasbach/react-complex-tree/issues/159"},"#159")))),(0,a.kt)("details",null,(0,a.kt)("summary",null,"I want to register a drag-start event or another event that is not available through RCTs API."),(0,a.kt)("div",null,(0,a.kt)("p",null,"Yeah, there are no direct hooks exposed to register for drag start events. But there are two other ways to hook into these kinds of event handlers yourself:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://rct.lukasbach.com/docs/guides/interaction-modes#custom-interaction-modes"},"Custom interaction managers"),": You can use a custom interaction manager to customize the event handlers that are mounted to the item component. You can extend existing modes, so you can fairly easily add only the hook you need on top of existing event handlers."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://rct.lukasbach.com/docs/guides/rendering#customizing-the-render-logic-for-tree-items"},"Custom render logic"),": This would be more effort and something I wouldn't recommend just for this, but you can also customize the render logic for tree items and mount the event there.")),(0,a.kt)("p",null,"Reference: ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/lukasbach/react-complex-tree/issues/156"},"#156")))),(0,a.kt)("details",null,(0,a.kt)("summary",null,"How can I implement a custom data provider?"),(0,a.kt)("div",null,(0,a.kt)("p",null,"You can look into the implementation of StaticTreeDataProvider for a more elaborate example: ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/lukasbach/react-complex-tree/blob/main/packages/core/src/uncontrolledEnvironment/StaticTreeDataProvider.ts"},"https://github.com/lukasbach/react-complex-tree/blob/main/packages/core/src/uncontrolledEnvironment/StaticTreeDataProvider.ts")),(0,a.kt)("p",null,"Reference: ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/lukasbach/react-complex-tree/issues/149"},"#149")))),(0,a.kt)("details",null,(0,a.kt)("summary",null,"I want to react to user actions, but not when reorder-actions are called"),(0,a.kt)("div",null,(0,a.kt)("p",null,"You can use onPrimaryAction for that."),(0,a.kt)("p",null,"There are no good docs on the exact logic right now, but the intent is that it calls when the user clicks on an item with probably no tree-navigation related intent. The exact logic you can see in the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/lukasbach/react-complex-tree/blob/main/packages/core/src/interactionMode/ClickItemToExpandInteractionManager.ts"},"implementation"),", and is pretty much"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"when shift is not pressed"),(0,a.kt)("li",{parentName:"ul"},"when control is not pressed"),(0,a.kt)("li",{parentName:"ul"},"[when the item is not a folder, or canInvokePrimaryActionOnItemContainer is true]")),(0,a.kt)("p",null,"You can test when it is triggered in ",(0,a.kt)("a",{parentName:"p",href:"https://rct.lukasbach.com/storybook/?path=/story/core-basic-examples--actions"},"this example"),"."),(0,a.kt)("p",null,"If you want to further customize which kind of user interaction triggers what, you can use ",(0,a.kt)("a",{parentName:"p",href:"https://rct.lukasbach.com/docs/guides/interaction-modes"},"custom interaction modes"),"\nfor that."),(0,a.kt)("p",null,"Reference: ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/lukasbach/react-complex-tree/issues/251"},"#251")))),(0,a.kt)("details",null,(0,a.kt)("summary",null,"Render methods for tree items or others unnecessarily re-render"),(0,a.kt)("p",null,"Yes, the render method for items are retriggered on tree state changes, since every item is provided with information about the tree state in their props, so tree items wouldn't be able to display data they otherwise can."),(0,a.kt)("p",null,"You can memoize the item render methods directly with only those props that you use, this will ensure that items are not rerendered unless they need to be: ",(0,a.kt)("a",{parentName:"p",href:"https://codesandbox.io/s/react-complex-tree-playground-memo-demo-37mngx"},"https://codesandbox.io/s/react-complex-tree-playground-memo-demo-37mngx")),(0,a.kt)("p",null,"Reference: ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/lukasbach/react-complex-tree/issues/291"},"#291"))))}u.isMDXComponent=!0},876:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var r=n(2784);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),h=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=h(e.components);return r.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),p=h(n),m=a,d=p["".concat(s,".").concat(m)]||p[m]||u[m]||o;return n?r.createElement(d,i(i({ref:t},c),{},{components:n})):r.createElement(d,i({ref:t},c))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=p;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var h=2;h<o;h++)i[h]=n[h];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"}}]);